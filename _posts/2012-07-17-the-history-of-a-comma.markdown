---
title: История одной запятой
---

Программисты в повседневной практике часто работают с различными перечислениями. Это могут быть элементы массива,
пары ключ-значения или, например, параметры метода. Существует одна хитрость при определении таких перечислений, которую я
использую уже очень давно и сегодня хочу поделиться с вами.

В C++ мы использовали следующую запись конструкторов:

``` cpp
SomeClass::SomeClass(int i_value, const std::string& i_string)
  : Base(i_value + 1)
  , m_value(i_value)
  , m_string(i_string)
  , m_float()
  , m_storage()
{
  // ...
}
```

Мы использовали явные вызовы конструкторов каждого члена класса, даже там где это можно было опустить, чтобы лучше контролировать
деятельность классов. Часто приходится жертвовать теоретическим изяществом ради достижения практических целей. Однако главное
не в этом. Обратите внимание на оформление запятых. Такая конструкция позволяет легко менять инициализаторы
местами и добавлять новые, не боясь получить синтаксическую ошибку. Это экономит немного времени и чуть-чуть нервных клетов.

В мире рейлс дела с перечислениями обстоят еще лучше, так как интерпретатор руби не такой строгий, как компилятор C++.
Можно объявлять массивы:

``` ruby
array = [
  'value1',
  123,          # <-- внимание, запятая!
]
```

хэши:

``` ruby
hash = {
  key: :value,
  anohter: 123, # <-- опять запятая!  
}
```

и вызывать методы:

``` ruby
some(
  'abc',
  123,          # <-- и снова она!
)
```

добавляя запятую в конце последнего члена перечисления. Возможно это синтаксически не совсем изящно, но работает
как ожидается и экономит время на длинных конструкциях.

В кофе-скрипт дела идут настолько замечательно, что запятых не нужно вообще:

``` coffeescript
some_method(
  1
  2
)

array = [
  4
  5
  6
]

hash = {
  a: 1
  b: 1
}
```

Джаваскрипт-интерпретатор в Хроме и Файерфоксе работает достойно:

``` javascript
array = [
  4,
  5,
  6,
];

hash = {
  a: 1,
  b: 1,
};
```

И наконец джаваскрипт в интернет-эксплорере выдает ошибку:

![](/assets/old/13-comma/ie.png)
