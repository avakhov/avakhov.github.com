<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>3 способа автоматического тестирования Javascript</title>
    <meta name="viewport" content="width=device-width">
    <link href="/fonts/all.css" rel="stylesheet">
    <style>* { font-family: 'PT Sans' !important; }</style>
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>
  <body>
    <div class="container">
      <div class="site">
        <div class="header">
  <h1 class="title"><a href="/">Blog</a></h1>
</div>
<h1>3 способа автоматического тестирования Javascript</h1>
<p class="meta">06 Nov 2012</p>

<div class="post">
<p>С++ я уважал за мощь и строгость, Руби обожаю за работу с строками, массивами и хэшами, но к Javascript всегда относился и продолжаю
относится холодно. Мне не нравится как осуществляется работа с <code>this</code>, смущает обилие операторов и зарезервированных
слов <code>undefined</code>, <code>null</code>, <code>Infinite</code>, <code>Nan</code>, <code>==</code>, <code>===</code>, а также я плохо ориентируются в колбеках. Кроме того, я не прочитал
ни одной книги по Javascript, что конечно же не способствует установлению приятельских отношений с этим языком.</p>

<p>Однако в ближайшие лет 5 вряд ли появится альтернатива для разработки на стороне клиента, поэтому с javascript придется работать еще
очень долго. В проекте, в котором я сейчас работаю, накопилось достаточно большое количество клиентского кода и пришла пора его тестировать
автоматически. Так как тема для меня новая, то я провел несколько эспериментов и
сегодня хочу предложить вашему вниманию 3 простых способа сделать ваш javascript более надежным.</p>

<p>Оговорюсь, что у нас простой интерфейс, однако есть сложные алгоритмические куски кода на javascript. Поэтому наши задачи идеально
подходят под классическое юнит-тестирование, про которое я буду рассказывать сегодня. Как тестировать сложный UI я
пока не знаю, так как с такой задачей еще не сталкивался.</p>

<h2>Способ 1. ExecJS</h2>

<p>Предположим, что нам нужно протестировать функцию, которая удаляет все элементы массива, совпадающие с заданным:</p>

<p><code>javascript app/assets/javascript/array.js
// Удаляет все элементы e из массива
Array.prototype.remove = function(e) {
  for (var i = 0; i &lt; this.length; i++) {
    if (this[i] === e) {
      this.splice(i, 1);
      i--;
    }
  }
  return this;
};
</code></p>

<p>Автоматические тесты запускаются на сервере после каждого комита, поэтому желательно, что бы js-тесты встроились в этот процесс.
К счастью в любом рейлс-приложении у нас уже есть все необходимые компоненты.
Гем <a href="https://github.com/sstephenson/execjs">execjs</a>, который используется при компилиции coffee-ассетов, можно использовать
для выполнения произвольного кода на сервере.</p>

<p>Добавляем <code>execjs</code> в секцию <code>test</code>:</p>

<p><code>ruby Gemfile
group :test do
  gem &#39;execjs&#39;
end
</code></p>

<p>Создаем спек для тестирования:</p>

<p>``` ruby spec/javascripts/array<em>spec.rb
require &#39;spec</em>helper&#39;</p>

<p>describe &quot;array.js&quot; do
  it &quot;implements Array#remove method&quot; do
    # Тестовые случаи
    spec = &lt;&lt;-JS
      var r1 = [1, 2, 2, 3].remove(2)
      var r2 = [1, 1, 1, 1].remove(1)
      // ...
    JS</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Создаем контекст
src = File.read(Rails.root.join(&#39;app/assets/javascripts/array.js&#39;))
js_context = ExecJS.compile(src + spec)

# Проверка ожиданий
js_context.eval(&#39;r1&#39;).should == [1, 3]
js_context.eval(&#39;r2&#39;).should == []
# ...
</code></pre></div>
<p>end
end
```</p>

<p>Запускаем спеки:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/proj/blog-2-js-testing<span class="o">(</span>1.9.3-p194<span class="o">)[</span>master<span class="o">]</span><span class="nv">$ </span>rspec
..

Finished in 0.32502 seconds
1 example, 0 failures
</code></pre></div>
<p>Вуаля, работает! Таким образом уже можно писать простые спеки.</p>

<p>Если файл, который нужно протестировать, написан на coffee-скрипте, то его можно скомпилировать с помощью гема <code>coffee-script</code>,
который также подключен к каждому рейлс-приложению:</p>

<p><code>ruby Gemfile
group :test do
  gem &#39;execjs&#39;
  gem &#39;coffee-script&#39;
end
</code></p>

<p>компилируем его следующим образом:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">  <span class="n">coffee</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;app/assets/javascripts/array.js&#39;</span><span class="p">))</span>
  <span class="n">src</span> <span class="o">=</span> <span class="no">CoffeeScript</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">coffee</span><span class="p">)</span>
  <span class="n">js_context</span> <span class="o">=</span> <span class="no">ExecJS</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
</code></pre></div>
<p>Конечно такого рода код для работы с js-файлами лучше выделить в отдельное место, но для проверки технологии можно оставить и так.</p>

<p>У данного метода тестирования есть много недостатков, главными из которых на мой взгляд являются: смешение js- и руби-кода в одном
файле, а также возможная потеря информации на границе ruby и скрипта (<code>undefined</code>, <code>null</code>, <code>Infinite</code> все перейдут в <code>nil</code>, кроме того
можно проверить только json-совместимые результаты). Главный положительный момент - тестирование органично встраивается
в регулярный прогон тестов и не требует никаких дополнительных настроек.</p>

<h2>Способ 2. Jasmine + ExecJS</h2>

<p>Я слышал положительные отзывы о библиотеке <a href="http://pivotal.github.com/jasmine/">jasmine</a>. Синтаксис выглядит приятно и rspec-подобно.
Поэтому решил модернизировать способ 1, чтобы писать спеки на чистом js (coffee).</p>

<p>Скачиваем файлы <a href="https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/jasmine.js">jasmine.js</a> и <a href="https://github.com/pivotal/jasmine/blob/master/src/console/ConsoleReporter.js">ConsoleReporter.js</a>, помещаем их в <code>vendor/assets/javascripts</code>.</p>

<p>Создаем файл, который будет запускать js-спеки. Он выглядит немного сложно, но так всегда происходит, когда мы начинаем
решать нестандартную задачу на стыке языков.</p>

<p>``` ruby spec/js_spec.rb</p>

<h1>encoding: utf-8</h1>

<p>require &#39;spec_helper&#39;</p>

<h1>Запустить js-спеки, используя jasmine и execjs</h1>

<p>describe &#39;JS specs&#39; do
  def assets(js<em>files)
    Array(js</em>files).map{ |js<em>file|
      if File.extname(js</em>file) == &#39;.coffee&#39;
        CoffeeScript.compile File.read(Rails.root.join(js<em>file))
      else
        File.read(Rails.root.join(js</em>file))
      end
    }.join(&quot;\n&quot;)
  end</p>

<p>ASSETS = [
    &#39;vendor/assets/javascripts/jasmine.js&#39;,
    &#39;vendor/assets/javascripts/ConsoleReporter.js&#39;,</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&#39;app/assets/javascripts/array.js&#39;
</code></pre></div>
<p>]</p>

<p>Dir[Rails.root.join(&#39;spec/javascripts/*<em>/</em><em>spec.js*&#39;)].each do |asset|
    it &quot;passed #{Pathname.new(asset).relative</em>path_from(Rails.root)}&quot; do
      # Подкладываем переменную <code>exports</code>, которая нужна jasmine.js
      src = &quot;var exports = {};\n&quot;</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  # Загружаем жасмин и тестируемый файл
  src += assets(ASSETS + [asset])

  # Подключаем jasmine reporter
  src += &lt;&lt;-JS
    var out = &quot;&quot;;
    var env = jasmine.getEnv();

    // Собирать вывод мы будем в переменную `out`
    var reporter = new jasmine.ConsoleReporter(function(msg){ out += msg; });

    // Скажем jasmine не использовать setTimeout и все сделать в один поток
    env.updateInterval = null;

    // Запускаем js-cпеки
    env.addReporter(reporter);
    env.execute();
  JS

  js_context = ExecJS.compile(src)

  # Используем assert, чтобы вывод в случае ошибки был понятнее
  out = js_context.eval(&#39;out&#39;)
  js_specs_passed = (out =~ /\d+ specs?, 0 failures/)
  assert js_specs_passed, out
end
</code></pre></div>
<p>end
end
```</p>

<p>Пишем наш первый спек с помощью жасмина:</p>

<p><code>coffeescript spec/javascripts/array_spec.js.coffee
describe &#39;Array&#39;, -&gt;
  it &quot;#remove&quot;, -&gt;
    expect([1, 2, 2, 3].remove(2)).toEqual([1, 3])
    expect([1, 1, 1, 1].remove(2)).toEqual([])
</code></p>

<p>Запускаем:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">~/proj/blog-2-js-testing<span class="o">(</span>1.9.3-p194<span class="o">)[</span>master<span class="o">]</span><span class="nv">$ </span>rspec
..

Finished in 0.57251 seconds
2 examples, 0 failures
</code></pre></div>
<p>Ура! Спеки пройдены.</p>

<p>Данный способ мне идеологически нравится гораздо больше, рассмотрим его недостатки:</p>

<ul>
<li>Не учитываются зависимости между файлами.</li>
<li>Нет возможности протестировать js, который работает с DOM.</li>
<li>Сложно находить ошибку, когда спеки падают.</li>
<li>Плохая гибкость, так как приходится указывать файлы явно.</li>
</ul>

<h2>Способ 3. ???</h2>

<p>Способ 3 я еще не придумал. Мне любопытно посмотреть на <code>jasmine-gem</code> и совместить его с <a href="http://phantomjs.org/">phantomjs</a>.
Так же интересно поиграть с <a href="https://github.com/jonleighton/poltergeist">полтергейстом</a> от Джона Лейгтона.
Я буду рад, если вы поделитесь своим опытом тестирования javascript, так как тема важная, но мне показалось, что
единого решения пока нет.</p>

<p>До новых встреч!</p>

<h3>Ссылки</h3>

<ul>
<li><a href="https://github.com/sstephenson/execjs">https://github.com/sstephenson/execjs</a> - execjs-гем</li>
<li><a href="https://github.com/avakhov/blog-2-js-testing">https://github.com/avakhov/blog-2-js-testing</a> - исходные кода демо приложения</li>
<li><a href="http://railscasts.com/episodes/297-running-javascript-in-ruby">http://railscasts.com/episodes/297-running-javascript-in-ruby</a> - Running JavaScript in Ruby</li>
<li><a href="http://pivotal.github.com/jasmine/">http://pivotal.github.com/jasmine/</a> - jasmine</li>
<li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/pathname/rdoc/Pathname.html#method-i-relative_path_from">Pathname#relative<em>path</em>from</a></li>
</ul>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'vakhov-me'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        <div class="footer">
          <div class="contact">
            <img src="https://secure.gravatar.com/avatar/54e74983d81fa2fbe4c28e8392532f18" class="logo">
          </div>
          <div class="contact">
            <p>
              Alexey Vakhov<br>
              <a href=mailto:vakhov@gmail.com>vakhov@gmail.com</a>
            </p>
          </div>
          <div class="contact">
            <p>
              <img src="/images/twitter.ico"> - <a href="https://twitter.com/#!/avakhov">twitter</a><br>
              <img src="/images/github.ico"> - <a href="https://github.com/avakhov">github</a><br>
              <img src="/images/skype.ico"> - avakhov
            </p>
          </div>
          <div class="contact">
            <p>
              <img src="/images/instagram.ico"> - <a href="http://instagram.com/avakhov">instagram</a><br>
            </p>
          </div>
        </div>
      </div>
    </div> <!-- /container -->
  </body>
</html>
