<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Покажи свой Monkey Patch</title>
    <meta name="viewport" content="width=device-width">
    <link href="/fonts/all.css" rel="stylesheet">
    <style>* { font-family: 'PT Sans' !important; }</style>
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link rel="stylesheet" href="/css/blog.css">
  </head>
  <body>
    <div class="container">
      <div class="site">
        <div class="header">
  <h1 class="title"><a href="/">Blog</a></h1>
</div>
<h1>Покажи свой Monkey Patch</h1>
<p class="meta">16 Nov 2012</p>

<div class="post">
<p>У меня всегда есть файл <code>config/initializers/_monkey_patching.rb</code>, в который я добавляю
необходимую низкоуровневую функциональность в рейлс и руби. Когда я плохо знал
возможности языка и фреймворка, этот файл был большой. Теперь я его регулярно
пересматриваю и по возможности переписываю код на стандартные механизмы.</p>

<p>Сегодня хочу поделиться с вами, что хранится у меня в этом файле сейчас.</p>

<h2>_ASSERT - реал-тайм проверки</h2>

<p>Когда проект разрастается программисты жертвуют компактностью и изяществом в пользу единообразия
и стандартизации. После некоторого размера (я его оцениваю примерно в 10-20 KLOC для руби-подобных
языков) один человек уже не в состоянии удержать в голове все нюансы программы одновременно.
Возникает необходимость доверять коду. Обычно это достигается с помощью написания модулей, классов,
систем с которыми можно взаимодейстовать как с черными ящиками с помощью формальных
интерфейсов.</p>

<p>Мне очень нравится идея разработки программного обеспечения, которая называется &quot;программирования
по конкракту&quot;. В википедии написано <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">много слов</a> на эту тему,
я предпочитаю программированием по контракту называть такой способ разработки методов и классов,
что они обязуются правильно работать при правильных аргументах. То есть черные ящики должны быть
крепко сколочены.</p>

<p>В С++ крепкость ящиков на нижнем уровне достигается строгой типизацией, вам
нужно достаточно хорошо умаслить
компилятор, чтобы он собрал ваш код, и ассертами - положительными утверждениями,
которые бросают эксепшен если утверждение оказалось ложным.</p>

<p>Выглядит это примерно так:</p>
<div class="highlight"><pre><code class="c++ language-c++" data-lang="c++"><span class="c1">// Возвращает корень числа `x`.</span>
<span class="c1">// Note: аргумент x должен быть неотрицательным.</span>
<span class="kt">float</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">_ASSERT</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Math</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Eсли мы передадим неправильный
аргумент, то программа разорвет с нами контракт и честно грохнется. По стеку гораздо легче
искать ошибку, чем если бы программа попыталась сохранить статус-кво и продолжила бы работать
с внутренними ошибками и противоречиями.</p>

<p>В руби рантайм-ошибки встречаются гораздо чаще (нет строгой типизации), частичную роль компиляции
выполняют тесты. В качестве ассерт-механизма я обычно использовал стандартные эксепшены:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">raise</span> <span class="s2">&quot;Some msg&quot;</span> <span class="k">if</span> <span class="n">something_wrong</span>
</code></pre></div>
<p>однако недавно завел формальный метод _ASSERT, который теперь использую значительно чаще.
Преимущество отдельного метода заключается в том, что не нужно каждый раз придумывать
сообщение об ошибке. Кроме того контрактные предположения становятся заметными.</p>

<p>Метод совсем простой, так как его значимость не техническая, а идеологическая:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="c1"># Runtime Assert as in all other languages</span>
<span class="k">def</span> <span class="nf">_ASSERT</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">condition</span>
    <span class="k">raise</span> <span class="s2">&quot;Runtime Error at </span><span class="si">#{</span><span class="nb">caller</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span> <span class="s1">&#39;&lt;root&gt;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h2>Each on steroids</h2>

<p>Бывает нужно пройтись по коллекции и особо обработать первый и последние элементы. Если коллекция
анонимная, то стандартными методами не получится отличить последний элемент от своих коллег.
Исторически я использую следующий метод:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Enumerable</span>
  <span class="k">class</span> <span class="nc">SteroidIter</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:index</span><span class="p">,</span> <span class="ss">:first</span><span class="p">,</span> <span class="ss">:last</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">first?</span><span class="p">;</span> <span class="n">first</span><span class="p">;</span> <span class="k">end</span>
    <span class="k">def</span> <span class="nf">last?</span><span class="p">;</span> <span class="n">last</span><span class="p">;</span> <span class="k">end</span>
    <span class="k">def</span> <span class="nf">to_i</span><span class="p">;</span> <span class="n">index</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Продвинутый #each_with_index с возможностью узнать является ли</span>
  <span class="c1"># текущий элемент первым/последним в коллекции.</span>
  <span class="c1">#</span>
  <span class="c1"># ==== Example</span>
  <span class="c1">#</span>
  <span class="c1">#   [1, 2, 3, 4].each_with_index do |elem, iter|</span>
  <span class="c1">#     if iter.first?</span>
  <span class="c1">#       puts &quot;first&quot;</span>
  <span class="c1">#     elsif iter.last?</span>
  <span class="c1">#       puts &quot;last&quot;</span>
  <span class="c1">#     else</span>
  <span class="c1">#       puts &quot;#{iter.to_i}.#{elem}&quot;</span>
  <span class="c1">#     end</span>
  <span class="c1">#   end</span>
  <span class="c1">#</span>
  <span class="c1">#   # =&gt;</span>
  <span class="c1">#   #  first</span>
  <span class="c1">#   #  1.2</span>
  <span class="c1">#   #  2.3</span>
  <span class="c1">#   #  last</span>
  <span class="c1">#</span>
  <span class="k">def</span> <span class="nf">each_on_steroids</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">elem</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
      <span class="k">yield</span> <span class="n">elem</span><span class="p">,</span> <span class="no">SteroidIter</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span> <span class="o">==</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h2>Дубликаты</h2>

<p>Несколько раз я сталкивался с задачей найти дублирующиеся элементы в коллекции. Задача довольно
не тривиальная и за 10 секунд я ее решить не смогу (<code>array - array.uniq</code>, который
мне всегда кажется, что должен решать эту задачу, к сожалению не работает). Поэтому родился
такой метод:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Enumerable</span>
  <span class="c1"># Returns all duplication in current collection</span>
  <span class="c1">#</span>
  <span class="c1"># ==== Example</span>
  <span class="c1">#</span>
  <span class="c1">#   [1, 4, 1, 3, 4, 4, 4].duplications # =&gt; [1, 4]</span>
  <span class="c1">#</span>
  <span class="k">def</span> <span class="nf">duplications</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">select</span><span class="p">{</span><span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">uniq</span>
  <span class="k">end</span>
<span class="k">end</span> 
</code></pre></div>
<h2>Assets Compilation Progress</h2>

<p>У нас ассеты собираются 2 минуты. Это значение находится на границе психологического комфорта,
когда еще не хочется разбираться и оптимизировать, но уже хочется потыкать программу во время
деплоя палкой, чтобы проверить не зависла ли она. Поэтому я немного расширил <code>sprockets</code>
компилятор, заставив его отчитываться после каждых 5 собранных ассетов. Наблюдать за деплоем
теперь стало гораздо занимательнее:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="c1"># Делает компиляцию ассетов более итеративной</span>
<span class="k">if</span> <span class="n">defined?</span><span class="p">(</span><span class="no">Sprockets</span><span class="p">)</span>
  <span class="k">module</span> <span class="nn">Sprockets</span>
    <span class="k">class</span> <span class="nc">StaticCompiler</span>
      <span class="n">cattr_accessor</span> <span class="ss">:processed</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span>

      <span class="k">def</span> <span class="nf">write_asset_with_logging</span><span class="p">(</span><span class="n">asset</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">processed</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
          <span class="nb">puts</span> <span class="s2">&quot;PROCESSED ASSETS: </span><span class="si">#{</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">processed</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">end</span>
        <span class="n">write_asset_without_logging</span><span class="p">(</span><span class="n">asset</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">alias_method_chain</span> <span class="ss">:write_asset</span><span class="p">,</span> <span class="ss">:logging</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Вот такие монкей-патчи. Несколько совсем уж специфических хаков я выкинул, но все самое
интересное показал. Спасибо за внимание.</p>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'vakhov-me'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        <div class="footer">
          <div class="contact">
            <img src="https://secure.gravatar.com/avatar/54e74983d81fa2fbe4c28e8392532f18" class="logo">
          </div>
          <div class="contact">
            <p>
              Alexey Vakhov<br>
              <a href=mailto:vakhov@gmail.com>vakhov@gmail.com</a>
            </p>
          </div>
          <div class="contact">
            <p>
              <img src="/images/twitter.ico"> - <a href="https://twitter.com/#!/avakhov">twitter</a><br>
              <img src="/images/github.ico"> - <a href="https://github.com/avakhov">github</a><br>
              <img src="/images/skype.ico"> - avakhov
            </p>
          </div>
          <div class="contact">
            <p>
              <img src="/images/instagram.ico"> - <a href="http://instagram.com/avakhov">instagram</a><br>
            </p>
          </div>
        </div>
      </div>
    </div> <!-- /container -->
  </body>
</html>
